<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêÖ Bagh-Chal: Tiger and Goats üêê</title>
    <style>
        /* CSS styles remain the same */
    </style>
</head>
<body>
<!-- Startup Modal -->
<div id="startupModal" class="modal" style="display:flex;align-items:center;justify-content:center;">
    <div class="modal-content" style="max-width:340px;text-align:center;">
        <h2 style="margin-bottom:20px;">Bagh-Chal: Select Mode</h2>
        <label for="startupModeSelect"><b>Choose Game Mode:</b></label>
        <select id="startupModeSelect" style="margin:16px 0;padding:10px 16px;font-size:16px;">
            <option value="human">Human vs Human</option>
            <option value="botTiger">Human vs Bot (Bot=Tigers)</option>
            <option value="botGoat">Human vs Bot (Bot=Goats)</option>
        </select>
        <br>
        <button id="startupStartBtn" class="btn btn-restart" style="font-size:18px;padding:14px 32px;margin-top:10px;">‚ñ∂Ô∏è Start Game</button>
    </div>
</div>
<!-- Quit Modal -->
<div id="quitModal" class="modal">
    <div class="modal-content" style="max-width:400px;text-align:center;">
        <span class="close" id="closeQuit">&times;</span>
        <h2 style="margin-bottom:20px;">‚ùå Quit Game</h2>
        <p>How would you like to quit?</p>
        <div class="quit-options">
            <div class="quit-option" id="quitToStart">üè† Return to Start Screen</div>
            <div class="quit-option" id="quitMinimize">üì± Minimize Window</div>
            <div class="quit-option" id="quitBlank">‚ö´ Show Blank Screen</div>
        </div>
        <button id="cancelQuit" class="btn btn-restart" style="margin-top:20px;">‚Ü©Ô∏è Cancel</button>
    </div>
</div>
<div class="title">üêÖ Bagh-Chal: Tiger and Goats üêê</div>
<div id="modeDisplay"></div>
<div class="status-panel">
    <div id="status">Loading game...</div>
</div>
<canvas id="gameCanvas" class="game-board" width="500" height="500"></canvas>
<div class="controls">
    <button id="restartBtn" class="btn btn-restart">üîÑ Restart Game</button>
    <button id="rulesBtn" class="btn btn-rules">üìñ Rules</button>
    <button id="quitBtn" class="btn btn-quit">‚ùå Quit</button>
</div>
<div class="instructions" id="instructions"></div>
<!-- Rules Modal -->
<div id="rulesModal" class="modal">
    <div class="modal-content">
        <span class="close" id="closeRules">&times;</span>
        <div class="rules-content">
            <h2>üêÖ BAGH-CHAL RULES üêê</h2>
            <h3>OBJECTIVE:</h3>
            <p>‚Ä¢ <strong>Tigers:</strong> Capture 5 goats to win<br>
                ‚Ä¢ <strong>Goats:</strong> Block all tigers so they cannot move</p>
            <h3>SETUP:</h3>
            <p>‚Ä¢ 4 tigers start at the corners<br>
                ‚Ä¢ 20 goats to be placed during the game</p>
            <h3>GAMEPLAY:</h3>
            <p><strong>1. PLACEMENT PHASE:</strong><br>
                ‚Ä¢ Goats are placed one by one on empty intersections<br>
                ‚Ä¢ After each goat placement, tigers can move</p>
            <p><strong>2. MOVEMENT PHASE</strong> (after all 20 goats are placed):<br>
                ‚Ä¢ Both tigers and goats can move to adjacent empty positions<br>
                ‚Ä¢ Tigers can also jump over goats to capture them<br>
                ‚Ä¢ Only one piece can be moved per turn</p>
            <h3>MOVEMENT RULES:</h3>
            <p>‚Ä¢ All pieces move along the lines to adjacent intersections<br>
                ‚Ä¢ Tigers can jump over adjacent goats to capture them<br>
                ‚Ä¢ Captured goats are removed from the board<br>
                ‚Ä¢ Goats cannot jump or capture</p>
            <h3>WIN CONDITIONS:</h3>
            <p>‚Ä¢ <strong>Tigers win</strong> by capturing 5 goats<br>
                ‚Ä¢ <strong>Goats win</strong> by blocking all tigers from moving</p>
        </div>
    </div>
</div>
<script>
    // Game constants
    const BOARD_SIZE = 5;
    const CANVAS_SIZE = 500;
    const CELL_SIZE = CANVAS_SIZE / (BOARD_SIZE + 1);
    const OFFSET = CELL_SIZE;
    // Game states
    const PLACEMENT_PHASE = 0;
    const MOVEMENT_PHASE = 1;
    // Piece types
    const EMPTY = 0;
    const TIGER = 1;
    const GOAT = 2;
    // Players
    const TIGER_PLAYER = 0;
    const GOAT_PLAYER = 1;
    // Game variables
    let currentPhase = PLACEMENT_PHASE;
    let currentPlayer = GOAT_PLAYER;
    let board = [];
    let goatsPlaced = 0;
    let goatsCaptured = 0;
    let selectedRow = -1;
    let selectedCol = -1;
    let pieceSelected = false;
    let gameOver = false;
    let winner = null;
    let connections = {};
    // Bot mode variables
    let botTiger = false;
    let botGoat = false;
    let gameStarted = false;
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // Initialize game
    function initGame() {
        setupConnections();
        setupEventListeners();
        setupStartupModal();
        resetGame();
    }
    function setupConnections() {
        connections = {};
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                const neighbors = [];
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                for (const [di, dj] of directions) {
                    const ni = i + di;
                    const nj = j + dj;
                    if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                        neighbors.push([ni, nj]);
                    }
                }
                connections[`${i},${j}`] = neighbors;
            }
        }
    }
    function setupEventListeners() {
        canvas.addEventListener('click', onCanvasClick);
        document.getElementById('restartBtn').addEventListener('click', () => {
            if (gameStarted) resetGame();
        });
        document.getElementById('rulesBtn').addEventListener('click', () => {
            if (gameStarted) showRules();
        });
        document.getElementById('quitBtn').addEventListener('click', () => {
            if (gameStarted) showQuitModal();
        });
        document.getElementById('closeRules').addEventListener('click', closeRules);
        document.getElementById('closeQuit').addEventListener('click', closeQuitModal);
        document.getElementById('cancelQuit').addEventListener('click', closeQuitModal);
        // Quit options
        document.getElementById('quitToStart').addEventListener('click', quitToStart);
        document.getElementById('quitMinimize').addEventListener('click', quitMinimize);
        document.getElementById('quitBlank').addEventListener('click', quitBlank);
        window.addEventListener('click', (event) => {
            const rulesModal = document.getElementById('rulesModal');
            const quitModal = document.getElementById('quitModal');
            if (event.target === rulesModal) {
                rulesModal.style.display = 'none';
            }
            if (event.target === quitModal) {
                quitModal.style.display = 'none';
            }
        });
    }
    function setupStartupModal() {
        document.getElementById('startupModal').style.display = 'flex';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('modeDisplay').style.display = 'none';
        enableControls(false);
        document.getElementById('startupStartBtn').addEventListener('click', () => {
            const mode = document.getElementById('startupModeSelect').value;
            botTiger = (mode === 'botTiger');
            botGoat = (mode === 'botGoat');
            updateModeDisplay();
            document.getElementById('startupModal').style.display = 'none';
            gameStarted = true;
            enableControls(true);
            document.getElementById('modeDisplay').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            resetGame();
        });
    }
    function enableControls(enable) {
        canvas.style.pointerEvents = enable ? 'auto' : 'none';
        document.getElementById('restartBtn').disabled = !enable;
        document.getElementById('rulesBtn').disabled = !enable;
        document.getElementById('quitBtn').disabled = !enable;
    }
    function updateModeDisplay() {
        let text = 'Mode: ';
        if (botTiger) text += 'Human vs Bot (Bot plays Tigers)';
        else if (botGoat) text += 'Human vs Bot (Bot plays Goats)';
        else text += 'Human vs Human';
        document.getElementById('modeDisplay').textContent = text;
    }
    function resetGame() {
        currentPhase = PLACEMENT_PHASE;
        currentPlayer = GOAT_PLAYER;
        board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
        goatsPlaced = 0;
        goatsCaptured = 0;
        selectedRow = -1;
        selectedCol = -1;
        pieceSelected = false;
        gameOver = false;
        winner = null;
        // Place initial tigers at corners
        board[0][0] = TIGER;
        board[0][4] = TIGER;
        board[4][0] = TIGER;
        board[4][4] = TIGER;
        drawBoard();
        updateStatus();
        // Start bot move if needed
        if (gameStarted) {
            setTimeout(botMoveIfNeeded, 500);
        }
    }
    function getCanvasCoords(row, col) {
        const x = OFFSET + col * CELL_SIZE;
        const y = OFFSET + row * CELL_SIZE;
        return [x, y];
    }
    function getBoardCoords(canvasX, canvasY) {
        const col = Math.round((canvasX - OFFSET) / CELL_SIZE);
        const row = Math.round((canvasY - OFFSET) / CELL_SIZE);
        if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
            return [row, col];
        }
        return [null, null];
    }
    function drawBoard() {
        ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        // Board background
        ctx.fillStyle = '#e8c27a';
        ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        // Draw grid lines
        ctx.strokeStyle = '#5a3a1b';
        ctx.lineWidth = 2.5;
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                const [x, y] = getCanvasCoords(i, j);
                const neighbors = connections[`${i},${j}`];
                for (const [ni, nj] of neighbors) {
                    if (ni > i || (ni === i && nj > j)) {
                        const [nx, ny] = getCanvasCoords(ni, nj);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(nx, ny);
                        ctx.stroke();
                    }
                }
            }
        }
        // Draw intersection points
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                const [x, y] = getCanvasCoords(i, j);
                ctx.fillStyle = '#ad8a56';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#5a3a1b';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }
        // Draw pieces
        drawPieces();
    }
    function drawPieces() {
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                const [x, y] = getCanvasCoords(i, j);
                if (board[i][j] === TIGER) {
                    // Draw tiger
                    ctx.fillStyle = '#c97a3a';
                    ctx.strokeStyle = '#5a3a1b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    // Tiger emoji
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#5a3a1b';
                    ctx.textAlign = 'center';
                    ctx.fillText('üêÖ', x, y + 6);
                } else if (board[i][j] === GOAT) {
                    // Draw goat
                    ctx.fillStyle = '#f5f3e7';
                    ctx.strokeStyle = '#5a3a1b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    // Goat emoji
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#ad8a56';
                    ctx.textAlign = 'center';
                    ctx.fillText('üêê', x, y + 6);
                }
            }
        }
        // Highlight selected piece
        if (pieceSelected) {
            const [x, y] = getCanvasCoords(selectedRow, selectedCol);
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, 2 * Math.PI);
            ctx.stroke();
        }
    }
    function isValidMove(fromRow, fromCol, toRow, toCol) {
        if (board[toRow][toCol] !== EMPTY) {
            return false;
        }
        // Check direct move (adjacent)
        const neighbors = connections[`${fromRow},${fromCol}`];
        for (const [nr, nc] of neighbors) {
            if (nr === toRow && nc === toCol) {
                return true;
            }
        }
        // Check tiger jump (capture)
        if (board[fromRow][fromCol] === TIGER) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            if ((rowDiff === 2 && colDiff === 0) || (rowDiff === 0 && colDiff === 2) || (rowDiff === 2 && colDiff === 2)) {
                const midRow = Math.floor((fromRow + toRow) / 2);
                const midCol = Math.floor((fromCol + toCol) / 2);
                if (board[midRow][midCol] === GOAT) {
                    return true;
                }
            }
        }
        return false;
    }
    function makeMove(fromRow, fromCol, toRow, toCol) {
        const piece = board[fromRow][fromCol];
        board[fromRow][fromCol] = EMPTY;
        board[toRow][toCol] = piece;
        // Check for capture
        if (piece === TIGER) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            if ((rowDiff === 2 && colDiff === 0) || (rowDiff === 0 && colDiff === 2) || (rowDiff === 2 && colDiff === 2)) {
                const midRow = Math.floor((fromRow + toRow) / 2);
                const midCol = Math.floor((fromCol + toCol) / 2);
                if (board[midRow][midCol] === GOAT) {
                    board[midRow][midCol] = EMPTY;
                    goatsCaptured++;
                }
            }
        }
    }
    function canTigersMove() {
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (board[i][j] === TIGER) {
                    // Check all possible moves
                    const neighbors = connections[`${i},${j}`];
                    for (const [ni, nj] of neighbors) {
                        if (isValidMove(i, j, ni, nj)) {
                            return true;
                        }
                    }
                    // Check jump moves
                    for (let di = -2; di <= 2; di += 2) {
                        for (let dj = -2; dj <= 2; dj += 2) {
                            if (di === 0 && dj === 0) continue;
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                                if (isValidMove(i, j, ni, nj)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    function checkWinCondition() {
        if (goatsCaptured >= 5) {
            gameOver = true;
            winner = "Tigers";
            setTimeout(() => alert("üêÖ Tigers Win! They captured 5 goats!"), 100);
        } else if (currentPhase === MOVEMENT_PHASE && !canTigersMove()) {
            gameOver = true;
            winner = "Goats";
            setTimeout(() => alert("üêê Goats Win! All tigers are blocked!"), 100);
        }
    }
    function onCanvasClick(event) {
        if (!gameStarted || gameOver) return;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const [row, col] = getBoardCoords(x, y);
        if (row === null || col === null) return;
        if (currentPhase === PLACEMENT_PHASE && currentPlayer === GOAT_PLAYER) {
            if (board[row][col] === EMPTY && goatsPlaced < 20) {
                board[row][col] = GOAT;
                goatsPlaced++;
                if (goatsPlaced === 20) {
                    currentPhase = MOVEMENT_PHASE;
                }
                currentPlayer = TIGER_PLAYER;
                drawBoard();
                updateStatus();
                checkWinCondition();
                setTimeout(botMoveIfNeeded, 500);
            }
        } else {
            // Movement phase or tiger turn in placement phase
            if (!pieceSelected) {
                // Select piece
                if ((currentPlayer === TIGER_PLAYER && board[row][col] === TIGER) ||
                    (currentPlayer === GOAT_PLAYER && board[row][col] === GOAT)) {
                    selectedRow = row;
                    selectedCol = col;
                    pieceSelected = true;
                    drawBoard();
                }
            } else {
                // Move piece or select different piece
                if (row === selectedRow && col === selectedCol) {
                    // Deselect
                    pieceSelected = false;
                    selectedRow = -1;
                    selectedCol = -1;
                    drawBoard();
                } else if (isValidMove(selectedRow, selectedCol, row, col)) {
                    // Make move
                    makeMove(selectedRow, selectedCol, row, col);
                    pieceSelected = false;
                    selectedRow = -1;
                    selectedCol = -1;
                    currentPlayer = 1 - currentPlayer;
                    drawBoard();
                    updateStatus();
                    checkWinCondition();
                    setTimeout(botMoveIfNeeded, 500);
                } else {
                    // Select different piece
                    if ((currentPlayer === TIGER_PLAYER && board[row][col] === TIGER) ||
                        (currentPlayer === GOAT_PLAYER && board[row][col] === GOAT)) {
                        selectedRow = row;
                        selectedCol = col;
                        pieceSelected = true;
                        drawBoard();
                    } else {
                        // Invalid selection, deselect
                        pieceSelected = false;
                        selectedRow = -1;
                        selectedCol = -1;
                        drawBoard();
                    }
                }
            }
        }
    }
    function botMoveIfNeeded() {
        if (gameOver || !gameStarted) return;
        // Check if it's bot's turn
        const isBotTurn = (currentPlayer === TIGER_PLAYER && botTiger) ||
            (currentPlayer === GOAT_PLAYER && botGoat);
        if (!isBotTurn) return;
        // Placement phase - bot goat
        if (currentPhase === PLACEMENT_PHASE && currentPlayer === GOAT_PLAYER && goatsPlaced < 20) {
            let empties = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === EMPTY) {
                        empties.push([i, j]);
                    }
                }
            }
            if (empties.length > 0) {
                const [row, col] = empties[Math.floor(Math.random() * empties.length)];
                board[row][col] = GOAT;
                goatsPlaced++;
                if (goatsPlaced === 20) {
                    currentPhase = MOVEMENT_PHASE;
                }
                currentPlayer = TIGER_PLAYER;
                drawBoard();
                updateStatus();
                checkWinCondition();
                setTimeout(botMoveIfNeeded, 500);
            }
        } else {
            // Movement phase or tiger turn in placement phase
            let moves = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if ((currentPlayer === TIGER_PLAYER && board[i][j] === TIGER) ||
                        (currentPlayer === GOAT_PLAYER && board[i][j] === GOAT)) {
                        // Check adjacent moves
                        const neighbors = connections[`${i},${j}`];
                        for (const [ni, nj] of neighbors) {
                            if (isValidMove(i, j, ni, nj)) {
                                moves.push([i, j, ni, nj]);
                            }
                        }
                        // Check jump moves for tigers
                        if (currentPlayer === TIGER_PLAYER) {
                            for (let di = -2; di <= 2; di += 2) {
                                for (let dj = -2; dj <= 2; dj += 2) {
                                    if (di === 0 && dj === 0) continue;
                                    const ni = i + di;
                                    const nj = j + dj;
                                    if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                                        if (isValidMove(i, j, ni, nj)) {
                                            moves.push([i, j, ni, nj]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (moves.length > 0) {
                const [fr, fc, tr, tc] = moves[Math.floor(Math.random() * moves.length)];
                makeMove(fr, fc, tr, tc);
                currentPlayer = 1 - currentPlayer;
                drawBoard();
                updateStatus();
                checkWinCondition();
                setTimeout(botMoveIfNeeded, 500);
            }
        }
    }
    function updateStatus() {
        let statusText, instructionText;
        if (gameOver) {
            statusText = `Game Over! Winner: ${winner}`;
            instructionText = `üéâ ${winner} have won the game! Click 'Restart Game' to play again.`;
        } else {
            if (currentPhase === PLACEMENT_PHASE) {
                statusText = `Placement Phase: ${20 - goatsPlaced} goats left to place`;
                instructionText = `Place a goat on an empty intersection.`;
            } else {
                statusText = `Movement Phase: ${currentPlayer === TIGER_PLAYER ? "Tigers" : "Goats"} turn`;
                instructionText = `Move a ${currentPlayer === TIGER_PLAYER ? "tiger" : "goat"} to an adjacent empty position.`;
            }
        }
        document.getElementById('status').textContent = statusText;
        document.getElementById('instructions').textContent = instructionText;
    }
    function showRules() {
        document.getElementById('rulesModal').style.display = 'flex';
    }
    function closeRules() {
        document.getElementById('rulesModal').style.display = 'none';
    }
    function showQuitModal() {
        document.getElementById('quitModal').style.display = 'flex';
    }
    function closeQuitModal() {
        document.getElementById('quitModal').style.display = 'none';
    }
    function quitToStart() {
        gameStarted = false;
        document.getElementById('startupModal').style.display = 'flex';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('modeDisplay').style.display = 'none';
        enableControls(false);
    }
    function quitMinimize() {
        window.minimize(); // This might not work in all environments
    }
    function quitBlank() {
        document.body.innerHTML = ''; // This will clear the entire page
    }

    // Initialize the game
    initGame();
</script>
</body>
</html>